"""
This type stub file was generated by pyright.
"""

import logging
from typing import Any, Callable, Dict, List, Literal, Optional, Tuple, Union
from ..utils.import_utils import is_pygments_available
from .prompts import SUPPORTED_PLAN_TYPES
from .tools import Tool

if is_pygments_available():
    ...
class CustomFormatter(logging.Formatter):
    grey = ...
    bold_yellow = ...
    red = ...
    green = ...
    bold_green = ...
    bold_red = ...
    bold_white = ...
    orange = ...
    bold_orange = ...
    reset = ...
    format = ...
    FORMATS = ...
    def format(self, record): # -> str:
        ...
    


logger = ...
ch = ...
def parse_json_blob(json_blob: str) -> Dict[str, str]:
    ...

def parse_code_blob(code_blob: str) -> str:
    ...

def parse_json_tool_call(json_blob: str) -> Tuple[str, Dict[str, str]]:
    ...

def parse_text_tool_call(text: str) -> Tuple[str, Union[str, Dict[str, str]]]:
    """
    Expects a text in the format: 'Action:', 'Action input:', 'Observation:'. 'Action input:' contains a json string with input arguments.
    """
    ...

def to_text(input: Union[List[Dict[str, str]], Dict[str, str], str]) -> str:
    ...

HUGGINGFACE_DEFAULT_TOOLS = ...
_tools_are_initialized = ...
class Toolbox:
    """
    The toolbox contains all tools that the agent can perform operations with, as well as a few methods to
    manage them.

    Args:
        tools (`List[Tool]`):
            The list of tools to instantiate the toolbox with
        add_base_tools (`bool`, defaults to `False`, *optional*, defaults to `False`):
            Whether to add the tools available within `transformers` to the toolbox.
    """
    def __init__(self, tools: List[Tool], add_base_tools: bool = ...) -> None:
        ...
    
    def add_base_tools(self, add_python_interpreter: bool = ...): # -> None:
        ...
    
    @property
    def tools(self) -> Dict[str, Tool]:
        """Get all tools currently in the toolbox"""
        ...
    
    def show_tool_descriptions(self, tool_description_template: str = ...) -> str:
        """
        Returns the description of all tools in the toolbox

        Args:
            tool_description_template (`str`, *optional*):
                The template to use to describe the tools. If not provided, the default template will be used.
        """
        ...
    
    def add_tool(self, tool: Tool): # -> None:
        """
        Adds a tool to the toolbox

        Args:
            tool (`Tool`):
                The tool to add to the toolbox.
        """
        ...
    
    def remove_tool(self, tool_name: str): # -> None:
        """
        Removes a tool from the toolbox

        Args:
            tool_name (`str`):
                The tool to remove from the toolbox.
        """
        ...
    
    def update_tool(self, tool: Tool): # -> None:
        """
        Updates a tool in the toolbox according to its name.

        Args:
            tool (`Tool`):
                The tool to update to the toolbox.
        """
        ...
    
    def clear_toolbox(self): # -> None:
        """Clears the toolbox"""
        ...
    
    def __repr__(self): # -> str:
        ...
    


class AgentError(Exception):
    """Base class for other agent-related exceptions"""
    def __init__(self, message) -> None:
        ...
    


class AgentParsingError(AgentError):
    """Exception raised for errors in parsing in the agent"""
    ...


class AgentExecutionError(AgentError):
    """Exception raised for errors in execution in the agent"""
    ...


class AgentMaxIterationsError(AgentError):
    """Exception raised for errors in execution in the agent"""
    ...


class AgentGenerationError(AgentError):
    """Exception raised for errors in generation in the agent"""
    ...


def format_prompt_with_tools(toolbox: Toolbox, prompt_template: str, tool_description_template: str) -> str:
    ...

def show_agents_descriptions(managed_agents: list): # -> str:
    ...

def format_prompt_with_managed_agents_descriptions(prompt_template, managed_agents=...) -> str:
    ...

def format_prompt_with_imports(prompt_template: str, authorized_imports: List[str]) -> str:
    ...

class Agent:
    def __init__(self, tools: Union[List[Tool], Toolbox], llm_engine: Callable = ..., system_prompt=..., tool_description_template=..., additional_args=..., max_iterations: int = ..., tool_parser=..., add_base_tools: bool = ..., verbose: int = ..., grammar: Dict[str, str] = ..., managed_agents: List = ...) -> None:
        ...
    
    @property
    def toolbox(self) -> Toolbox:
        """Get the toolbox currently available to the agent"""
        ...
    
    def initialize_for_run(self): # -> None:
        ...
    
    def write_inner_memory_from_logs(self, summary_mode: Optional[bool] = ...) -> List[Dict[str, str]]:
        """
        Reads past llm_outputs, actions, and observations or errors from the logs into a series of messages
        that can be used as input to the LLM.
        """
        ...
    
    def get_succinct_logs(self): # -> list[dict[str, Any]]:
        ...
    
    def extract_action(self, llm_output: str, split_token: str) -> str:
        """
        Parse action from the LLM output

        Args:
            llm_output (`str`): Output of the LLM
            split_token (`str`): Separator for the action. Should match the example in the system prompt.
        """
        ...
    
    def execute_tool_call(self, tool_name: str, arguments: Dict[str, str]) -> Any:
        """
        Execute tool with the provided input and returns the result.
        This method replaces arguments with the actual values from the state if they refer to state variables.

        Args:
            tool_name (`str`): Name of the Tool to execute (should be one from self.toolbox).
            arguments (Dict[str, str]): Arguments passed to the Tool.
        """
        ...
    
    def log_rationale_code_action(self, rationale: str, code_action: str) -> None:
        ...
    
    def run(self, **kwargs):
        """To be implemented in the child class"""
        ...
    


class CodeAgent(Agent):
    """
    A class for an agent that solves the given task using a single block of code. It plans all its actions, then executes all in one shot.
    """
    def __init__(self, tools: List[Tool], llm_engine: Callable = ..., system_prompt: str = ..., tool_description_template: str = ..., grammar: Dict[str, str] = ..., additional_authorized_imports: Optional[List[str]] = ..., **kwargs) -> None:
        ...
    
    def parse_code_blob(self, result: str) -> str:
        """
        Override this method if you want to change the way the code is
        cleaned in the `run` method.
        """
        ...
    
    def run(self, task: str, return_generated_code: bool = ..., **kwargs): # -> str | list[Any] | Any | tuple[Any, ...] | bool | Series | Callable[..., Any | list[Any] | tuple[Any, ...] | bool | Series | ... | Callable[..., Any] | dict[Any, Any] | str | DataFrame | ndarray[Any, Any] | NDArray[Any] | slice | set[Any] | None] | Callable[..., Any] | dict[Any, Any] | DataFrame | ndarray[Any, Any] | NDArray[Any] | slice | set[Any] | None:
        """
        Runs the agent for the given task.

        Args:
            task (`str`): The task to perform
            return_generated_code (`bool`, *optional*, defaults to `False`): Whether to return the generated code instead of running it
            kwargs (additional keyword arguments, *optional*):
                Any keyword argument to send to the agent when evaluating the code.

        Example:

        ```py
        from transformers.agents import CodeAgent

        agent = CodeAgent(tools=[])
        agent.run("What is the result of 2 power 3.7384?")
        ```
        """
        ...
    


class ReactAgent(Agent):
    """
    This agent that solves the given task step by step, using the ReAct framework:
    While the objective is not reached, the agent will perform a cycle of thinking and acting.
    The action will be parsed from the LLM output: it consists in calls to tools from the toolbox, with arguments chosen by the LLM engine.
    """
    def __init__(self, tools: List[Tool], llm_engine: Callable = ..., system_prompt: str = ..., tool_description_template: str = ..., grammar: Dict[str, str] = ..., plan_type: Literal[tuple(SUPPORTED_PLAN_TYPES)] = ..., planning_interval: Optional[int] = ..., **kwargs) -> None:
        ...
    
    def provide_final_answer(self, task) -> str:
        """
        This method provides a final answer to the task, based on the logs of the agent's interactions.
        """
        ...
    
    def run(self, task: str, stream: bool = ..., reset: bool = ..., **kwargs): # -> Generator[dict[str, Any] | dict[str, AgentMaxIterationsError] | str | Any | None, Any, None] | str | None:
        """
        Runs the agent for the given task.

        Args:
            task (`str`): The task to perform

        Example:
        ```py
        from transformers.agents import ReactCodeAgent
        agent = ReactCodeAgent(tools=[])
        agent.run("What is the result of 2 power 3.7384?")
        ```
        """
        ...
    
    def stream_run(self, task: str): # -> Generator[dict[str, Any] | dict[str, AgentMaxIterationsError] | str | Any | None, Any, None]:
        """
        Runs the agent in streaming mode, yielding steps as they are executed: should be launched only in the `run` method.
        """
        ...
    
    def direct_run(self, task: str): # -> str | None:
        """
        Runs the agent in direct mode, returning outputs only at the end: should be launched only in the `run` method.
        """
        ...
    
    def planning_step(self, task, is_first_step: bool = ..., iteration: int = ...): # -> None:
        """
        Used periodically by the agent to plan the next steps to reach the objective.

        Args:
            task (`str`): The task to perform
            is_first_step (`bool`): If this step is not the first one, the plan should be an update over a previous plan.
            iteration (`int`): The number of the current step, used as an indication for the LLM.
        """
        ...
    


class ReactJsonAgent(ReactAgent):
    """
    This agent that solves the given task step by step, using the ReAct framework:
    While the objective is not reached, the agent will perform a cycle of thinking and acting.
    The tool calls will be formulated by the LLM in JSON format, then parsed and executed.
    """
    def __init__(self, tools: List[Tool], llm_engine: Callable = ..., system_prompt: str = ..., tool_description_template: str = ..., grammar: Dict[str, str] = ..., planning_interval: Optional[int] = ..., **kwargs) -> None:
        ...
    
    def step(self): # -> dict[Any, Any]:
        """
        Perform one step in the ReAct framework: the agent thinks, acts, and observes the result.
        The errors are raised here, they are caught and logged in the run() method.
        """
        ...
    


class ReactCodeAgent(ReactAgent):
    """
    This agent that solves the given task step by step, using the ReAct framework:
    While the objective is not reached, the agent will perform a cycle of thinking and acting.
    The tool calls will be formulated by the LLM in code format, then parsed and executed.
    """
    def __init__(self, tools: List[Tool], llm_engine: Callable = ..., system_prompt: str = ..., tool_description_template: str = ..., grammar: Dict[str, str] = ..., additional_authorized_imports: Optional[List[str]] = ..., planning_interval: Optional[int] = ..., **kwargs) -> None:
        ...
    
    def step(self): # -> dict[Any, Any]:
        """
        Perform one step in the ReAct framework: the agent thinks, acts, and observes the result.
        The errors are raised here, they are caught and logged in the run() method.
        """
        ...
    


class ManagedAgent:
    def __init__(self, agent, name, description, additional_prompting=..., provide_run_summary=...) -> None:
        ...
    
    def write_full_task(self, task): # -> str:
        ...
    
    def __call__(self, request, **kwargs): # -> str:
        ...
    


