"""
This type stub file was generated by pyright.
"""

import ast
from typing import Any, Callable, Dict, List, Optional
from ..utils import is_pandas_available

if is_pandas_available():
    ...
class InterpreterError(ValueError):
    """
    An error raised when the interpretor cannot evaluate a Python expression, due to syntax error or unsupported
    operations.
    """
    ...


ERRORS = ...
LIST_SAFE_MODULES = ...
class BreakException(Exception):
    ...


class ContinueException(Exception):
    ...


class ReturnException(Exception):
    def __init__(self, value) -> None:
        ...
    


def get_iterable(obj): # -> list[Any]:
    ...

def evaluate_unaryop(expression, state, static_tools, custom_tools): # -> bool:
    ...

def evaluate_lambda(lambda_expression, state, static_tools, custom_tools): # -> Callable[..., Any | list[Any] | tuple[Any, ...] | bool | Series | Callable[..., ...] | Callable[..., Any] | dict[Any, Any] | str | DataFrame | ndarray[Any, Any] | NDArray[Any] | slice | set[Any] | None]:
    ...

def evaluate_while(while_loop, state, static_tools, custom_tools): # -> None:
    ...

def create_function(func_def, state, static_tools, custom_tools): # -> Callable[..., Any | list[Any] | tuple[Any, ...] | bool | Series | Callable[..., Any | list[Any] | tuple[Any, ...] | bool | Series | ... | Callable[..., Any] | dict[Any, Any] | str | DataFrame | ndarray[Any, Any] | NDArray[Any] | slice | set[Any] | None] | Callable[..., Any] | dict[Any, Any] | str | DataFrame | ndarray[Any, Any] | NDArray[Any] | slice | set[Any] | None]:
    ...

def create_class(class_name, class_bases, class_body): # -> Any:
    ...

def evaluate_function_def(func_def, state, static_tools, custom_tools):
    ...

def evaluate_class_def(class_def, state, static_tools, custom_tools): # -> Any:
    ...

def evaluate_augassign(expression, state, static_tools, custom_tools): # -> list[Any]:
    ...

def evaluate_boolop(node, state, static_tools, custom_tools): # -> bool | None:
    ...

def evaluate_binop(binop, state, static_tools, custom_tools):
    ...

def evaluate_assign(assign, state, static_tools, custom_tools):
    ...

def set_value(target, value, state, static_tools, custom_tools): # -> None:
    ...

def evaluate_call(call, state, static_tools, custom_tools): # -> Any | None:
    ...

def evaluate_subscript(subscript, state, static_tools, custom_tools): # -> Series | DataFrame | Any | ndarray[Any, Any] | NDArray[Any] | str:
    ...

def evaluate_name(name, state, static_tools, custom_tools): # -> Any:
    ...

def evaluate_condition(condition, state, static_tools, custom_tools): # -> bool | Series:
    ...

def evaluate_if(if_statement, state, static_tools, custom_tools): # -> None:
    ...

def evaluate_for(for_loop, state, static_tools, custom_tools): # -> None:
    ...

def evaluate_listcomp(listcomp, state, static_tools, custom_tools): # -> list[Any]:
    ...

def evaluate_try(try_node, state, static_tools, custom_tools): # -> None:
    ...

def evaluate_raise(raise_node, state, static_tools, custom_tools):
    ...

def evaluate_assert(assert_node, state, static_tools, custom_tools): # -> None:
    ...

def evaluate_with(with_node, state, static_tools, custom_tools): # -> None:
    ...

def import_modules(expression, state, authorized_imports): # -> None:
    ...

def evaluate_dictcomp(dictcomp, state, static_tools, custom_tools): # -> dict[Any, Any]:
    ...

def evaluate_ast(expression: ast.AST, state: Dict[str, Any], static_tools: Dict[str, Callable], custom_tools: Dict[str, Callable], authorized_imports: List[str] = ...): # -> list[Any] | Any | tuple[Any, ...] | bool | Series | Callable[..., Any | list[Any] | tuple[Any, ...] | bool | Series | ... | Callable[..., Any] | dict[Any, Any] | str | DataFrame | ndarray[Any, Any] | NDArray[Any] | slice | set[Any] | None] | Callable[..., Any] | dict[Any, Any] | str | DataFrame | ndarray[Any, Any] | NDArray[Any] | slice | set[Any] | None:
    """
    Evaluate an abstract syntax tree using the content of the variables stored in a state and only evaluating a given
    set of functions.

    This function will recurse trough the nodes of the tree provided.

    Args:
        expression (`ast.AST`):
            The code to evaluate, as an abstract syntax tree.
        state (`Dict[str, Any]`):
            A dictionary mapping variable names to values. The `state` is updated if need be when the evaluation
            encounters assignements.
        static_tools (`Dict[str, Callable]`):
            Functions that may be called during the evaluation. Trying to change one of these static_tools will raise an error.
        custom_tools (`Dict[str, Callable]`):
            Functions that may be called during the evaluation. These static_tools can be overwritten.
        authorized_imports (`List[str]`):
            The list of modules that can be imported by the code. By default, only a few safe modules are allowed.
            Add more at your own risk!
    """
    ...

def evaluate_python_code(code: str, static_tools: Optional[Dict[str, Callable]] = ..., custom_tools: Optional[Dict[str, Callable]] = ..., state: Optional[Dict[str, Any]] = ..., authorized_imports: List[str] = ...): # -> list[Any] | Any | tuple[Any, ...] | bool | Series | Callable[..., Any | list[Any] | tuple[Any, ...] | bool | Series | ... | Callable[..., Any] | dict[Any, Any] | str | DataFrame | ndarray[Any, Any] | NDArray[Any] | slice | set[Any] | None] | Callable[..., Any] | dict[Any, Any] | str | DataFrame | ndarray[Any, Any] | NDArray[Any] | slice | set[Any] | None:
    """
    Evaluate a python expression using the content of the variables stored in a state and only evaluating a given set
    of functions.

    This function will recurse through the nodes of the tree provided.

    Args:
        code (`str`):
            The code to evaluate.
        static_tools (`Dict[str, Callable]`):
            The functions that may be called during the evaluation.
            These tools cannot be overwritten in the code: any assignment to their name will raise an error.
        custom_tools (`Dict[str, Callable]`):
            The functions that may be called during the evaluation.
            These tools can be overwritten in the code: any assignment to their name will overwrite them.
        state (`Dict[str, Any]`):
            A dictionary mapping variable names to values. The `state` should contain the initial inputs but will be
            updated by this function to contain all variables as they are evaluated.
            The print outputs will be stored in the state under the key 'print_outputs'.
    """
    ...

